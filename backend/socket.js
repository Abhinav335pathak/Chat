const WebSocket = require("ws");
const jwt = require("jsonwebtoken");
const User = require("./models/User");
const Conversation = require("./models/Conversation");
const Message = require("./models/Message");

const initWebSocket = (server) => {
  const wss = new WebSocket.Server({ server, path: "/ws" });

  const clients = new Map();
  const lastActiveUpdate = new Map();

  wss.on("connection", async (ws, req) => {
    try {
      const params = new URLSearchParams(req.url.split("?")[1]);
      const token = params.get("token");

      if (!token) {
        ws.close();
        return;
      }

      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      const userId = decoded.id;

      clients.set(userId, ws);
      lastActiveUpdate.set(userId, Date.now());

      console.log("‚úÖ WS connected:", userId);

      // ws.on("message", async (data) => {
      //   const payload = JSON.parse(data.toString());
      //   if (payload.type !== "message") return;

      //   const { conversation, ciphertext, iv } = payload;

      //   const msg = await Message.create({
      //     conversation,
      //     sender: userId,
      //     ciphertext,
      //     iv,
      //   });

      //   const populated = await msg.populate("sender", "name email avatar");

      //   const conv = await Conversation.findById(conversation);
      //   conv.members.forEach((memberId) => {
      //     const client = clients.get(memberId.toString());
      //     if (client && client.readyState === WebSocket.OPEN) {
      //       client.send(JSON.stringify(populated));
      //     }
      //   });
      // });
      //     ws.on("message", async (data) => {
      //   const payload = JSON.parse(data.toString());
      //   if (payload.type !== "message") return;

      //   const { conversation, ciphertext, iv } = payload;

      //   const msg = await Message.create({
      //     conversation,
      //     sender: userId,
      //     ciphertext,
      //     iv,
      //   });

      //   const populated = await msg.populate("sender", "name email avatar");

      //   const conv = await Conversation.findById(conversation);
      //   conv.members.forEach((memberId) => {
      //     const client = clients.get(memberId.toString());
      //     if (client && client.readyState === WebSocket.OPEN) {
      //       client.send(JSON.stringify(populated));
      //     }
      //   });
      // });
ws.on("message", async (data) => {
  try {
    const payload = JSON.parse(data.toString());
    if (payload.type !== "message") return;

    // ‚ùå REMOVE: Message.create(...) - It is already saved via the Controller
    
    // The payload coming from useSendMessage now contains the FULL populated message 
    // including the _id and media generated by the API/Controller.
    const messageToBroadcast = payload;

    const conv = await Conversation.findById(messageToBroadcast.conversation);
    if (!conv) return;

    conv.members.forEach((memberId) => {
      const memberIdStr = memberId.toString();
      
      // OPTIONAL: Only send to OTHERS, not the sender 
      // (This is safer if you update the sender's UI immediately via API response)
      if (memberIdStr === userId) return; 

      const client = clients.get(memberIdStr);
      if (client && client.readyState === WebSocket.OPEN) {
        client.send(JSON.stringify(messageToBroadcast));
      }
    });
  } catch (err) {
    console.error("WS Message Error:", err.message);
  }
});
      ws.on("close", async () => {
        try {
          clients.delete(userId);
          lastActiveUpdate.delete(userId);

          await User.findByIdAndUpdate(userId, {
            lastWsDisconnect: new Date(),
          });

          console.log("‚ùå WS disconnected:", userId);
        } catch (err) {
          console.error("Failed to update lastWsDisconnect:", err.message);
        }
      });

    } catch (err) {
      console.error("WS auth failed:", err.message);
      ws.close();
    }
  });

  console.log("üöÄ WebSocket server running at ws://localhost:4000/ws");
};

module.exports = initWebSocket;
